# This script reads in all the traits from the given directory, and generates a C++ header
# defining these as constants from it

import sys
from pathlib import Path
from xml.etree import ElementTree as ET
from collections import namedtuple

EventSpec = namedtuple("EventSpec", ["name", "file", "function"])


def parse_event(trait: ET.Element):
    return EventSpec(name=trait.attrib["Name"], file=trait.attrib["Script"], function=trait.attrib["Function"])


def parse_file(events_file: Path):
    doc = ET.fromstring(events_file.read_text())

    traits = []

    for child in doc:
        if child.tag == "Event":
            traits.append(parse_event(child))
        else:
            print("Warning: Unknown tag ", child.tag)

    return traits


def name_as_identifier(trait_name: str):
    return trait_name.upper().replace(" ", "_").replace("-", "_").replace(".", "_").replace(":", "_")


def main():
    search_path = Path(sys.argv[1])
    result_path = Path(sys.argv[2])
    result_path.parent.mkdir(exist_ok=True, parents=True)

    out_text = "/// This file is automatically generated. Do not change, modifications will be overwritten.\n\n"
    out_text += "#pragma once\n\n"
    out_text += "namespace events {\n"
    for events_file in search_path.glob("*.xml"):
        out_text += f"\n\n    // {events_file.name}\n"
        try:
            new_events = parse_file(events_file)
        except Exception as E:
            print(f"Error parsing file '{events_file}'")
            raise

        for event in new_events:
            out_text += f"    // {event.file}: {event.function}\n"
            out_text += f"    constexpr const char* {name_as_identifier(event.name)} = \"{event.name}\";\n\n"

    out_text += "}\n"
    # only write to the file if anything actually changes.
    if not result_path.exists() or result_path.read_text() != out_text:
        result_path.write_text(out_text)


if __name__ == "__main__":
    main()
